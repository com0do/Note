 进程和线程的共享

本文档可以说明以下几个问题：

问题一：多进程编程中，不同进程是否可以通过全局变量来通信?

问题二：多线程编程中，不同线程是否可以通过全局变量来通信？

 

在说明这两个问题之前，首先说明对于进程使用的内存的分段结构(高地址--->低地址)：

   环境变量：   存放进程的环境变量信息。

   栈：                临时变量、返回地址、函数入参等。

   堆：                malloc就在这地方申请。

   BSS段：        存放未初始化的全局变量，未初始化的静态变量(无论该静态变量在函数内定义还是函数外定义，都存放在这里)。

   数据段(DS)：存放初始化过的全局变量，初始化过的静态变量。

   代码段(CS)：存放程序的代码。

 

【问题一】

对于兄弟的进程或者父子进程中有一方使用了exec族函数(进程的代码、数据全部被替换，实际使用的物理内存也是重新申请的)，进程的代码段、数据段、堆栈段都是独立的，没有任何关系，当然系统会为为他们各自都维护页目录和页表信息(每个进程有自己的页目录和页表)。

对于父子进程，假设我们在代码中定义了一个全局变量g_test =1;当使用fork()系统调用时，子进程使用的页目录和页表是复制父进程的，所有此时父子进程共享所有数据(当然fork()的返回值不一样，信号位图也不一样)，所以这个时候父子进程读取全局变量g_test的值以及地址都是一样的，因为g_test是被共享的，g_test这块内存在两个进程的页表中都映射了同一块物理内存。

如果之后父子进程中有一方执行了写操作(比如子进程进行g_test++)，子进程在在查找页表时会发现这页内存是共享的(内存引用计数大于1)，这时候就触发了写时复制COW机制，系统会为子进程申请一页新内存，并拷贝父进程g_test所在内存页的数据到子进程新申请的内存中，并更新子进程中页表信息(g_test所对应的线性地址映射到新内存)，然后再执行g_test++操作。

此时父子进程访问g_test时，虽然变量名一样，变量的线性地址一样(printf(&g_test))，但是他们的值是不一样的，因为这个时候，父子进程的g_test被映射到了不同的物理内存中。

 

【问题二】

首先对于不同进程的线程而言，他们没有什么关系的(代码段、数据段等都不同)，所以不能通过全局变量来通信。

但是对于同一进程内的线程，他们是可以通过全局变量来通信的。

同一进程内的线程，他们都共享进程的代码段、数据段、BSS段。页目录和页表应该是使用进程的页目录和页表。

 

对于上面的描述，又产生一个新问题：我们在编写驱动程序的时候，对于全局变量的使用一般都要考虑并发，也就是说这时候全局变量是共享的，这和问题一有出入。

实际上，当进程进入内核执行时，所有进程共享内核的代码段和数据段，所以在内核中，全局变量是共享的，访问时要考虑并发和竞态。(所有进程共享内核的页目录和页表结构)

--------------------【文件同步写入】--

fflush是libc.a中提供的方法，

fsync是系统提供的系统调用。

2.原形

fflush接受一个参数FILE *.

fflush(FILE *);

fsync接受的时一个Int型的文件描述符。

fsync(int fd);

3.功能

fflush:是把C库中的缓冲调用write函数写到磁盘[其实是写到内核的缓冲区]。

fsync：是把内核缓冲刷到磁盘上。

c库缓冲-----fflush---------〉内核缓冲--------fsync-----〉磁盘


-------------------------------sem---------------
sem_wait   sem_post
信号量的数据类型为结构sem_t，它本质上是一个长整型的数。函数sem_init（）用来初始化一个信号量。它的原型为：　　
extern int sem_init __P ((sem_t *__sem, int __pshared, unsigned int __value));　　

sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。　　

函数sem_post( sem_t *sem )用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。　　

函数sem_wait( sem_t *sem )被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait ( sem_t *sem )是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。　　

函数sem_destroy(sem_t *sem)用来释放信号量sem。　

信号量用sem_init函数创建的，下面是它的说明：
　　#include<semaphore.h>
 int sem_init (sem_t *sem, int pshared, unsigned int value);

 这个函数的作用是对由sem指定的信号量进行初始化，设置好它的共享选项，并指定一个整数类型的初始值。pshared参数控制着信号量的类型。如果 pshared的值是０，就表示它是当前里程的局部信号量；否则，其它进程就能够共享这个信号量。我们现在只对不让进程共享的信号量感兴趣。　（这个参数受版本影响），　pshared传递一个非零将会使函数调用失败。


全局变量在fork的子进程中，是从父进程copy了一份（事实是整个进程地址空间都copy了一份），系统出于效率考虑，没有真拷贝，而是与父进程共享同一页，只有数据改变时，才为子进程分配内存并复制改变后数据到新页。这个技巧叫copy on write。
同一进程下的所有线程共享访问进程空间内的全局变量（并发访问时应该加锁以保证数据读写的完整性）。

同一进程内的线程共享访问全局变量。
那么对于进程里面的函数的栈上的局部变量来说，是不是在特定的前提下，也是可以做到共享访问的？
比如，对于每一个线程的启动函数，传递的参数是创建进程的函数的局部变量的地址，那么多个线程可以在锁机制的保护下
共享访问这个局部变量。
当然前提是，这个被访问的局部变量必须保证在所有线程都返回后，才可以被销毁。也就是说，
必须要求等所有的线程对这个变量的访问都完全结束后，进程里面的函数才可以结束，或者返回或者退出。
这样才能保证所有线程里面访问的变量是一个有效的变量。

关于创建守护进程fork两次的原因如下：
           第一次fork前：在开始运行且fork之前拥有一个会话两个进程组：shell拥有一个进程组，你运行的程序拥有一个进程组，且他们都是组长进程；shell还是会话首进程
           第一次fork后：父进程的退出带来的变化是告知shell命令已完成；新创建的子进程不可能是组长进程(因为父进程在它之前创建)。这为接下来调用setsid做准备(因为调用setsid()的进程不能是组长进程)
           第二次fork原因：在调用setsid()后，原来的子进程现在在一个新会话里面，新会话里有一个进程组并且它就是组长进程。而且如果原来有终端现在也分离了。然而问题就处在这里，组长进程是有可能获得终端的，为了防止它以后获得终端，所以再次fork来消除潜在问题

SUID 	设置用户ID [SUID](https://blog.csdn.net/charles_neil/article/details/79762334)
	ls /usr/bin/passwd
	有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。　
